<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_kirby_still</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_kirby_mask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize platforming variables

//Platforming constants
WALK_SPD = 4
DASH_SPD = 6
SLIDING_SPD = 10
FLOAT_SPD = 6
BOUNCE_SPD = 8  //can go up 1 block

GRAV = 1
VSP_MAX = 8

FLOAT_GRAV = 0.5
VSP_MAX_FLOAT = 2

JUMP_SPD = 14
JUMP_DECEL = 2

ACCELERATION = 1
DECELERATION = 0.5
SKID_DECELERATION = 1


//Platforming timer constants
DASH_TIMER = 6
BUTTON_HOLD_THRESHOLD = 30  //1 * global.game_speed
SUPER_INHALE_THRESHOLD = 30 //1 * global.game_speed 


//Collision constants
FEET_OFFSET = bbox_bottom - bbox_top + 1
SMALL_GAP_OFFSET = 4 //use for snapping when jumping through small gaps
mask_index = spr_kirby_mask

//Animation constants
PUFFING_TIMER = 10
UPDATE_FALLING_TIMER = 20
EXHAUST_THRESHOLD = 60      //2 * global.game_speed
EXHAUST_TIMER = 30          //for waiting until finish exhausting
INHALING_ENEMY_TIMER = 10   //for waiting until finish inhaling enemy/block
INHALE_DELAY = 6           //use for stopping delay after releasing button
STUFFING_DELAY = 6
SPIT_TIMER = 10
SWALLOW_TIMER = sprite_get_number(spr_kirby_swallow)    //for waiting until finish swallowing

//Animation variables
loop_animation = true


//Platforming variables
hsp=0
vsp=0
dir=1
last_dir=0
on_ground=true
is_moving=0
inhale_range_obj = noone    //inhale range object
transformable = false
ability = -1

depth = global.player_depth

//Player states

jumping = 0
skidding = 0
dashing = 0
floating = 0
falling = 0
puffing = 0
ducking = 0
sliding = 0

//Inhaling states
//inhaling &gt; inhaling_enemy &gt; stuffing &gt; stuffed
inhaling = 0            //just inhaling (0 is not inhaling, 1 is inhaling, 2 is super inhaling) 
inhaling_enemy = false   //temporary state of when an enemy is being inhaled
stuffing = false        //transition state from inhaling to stuffed
stuffed = false         //BIG kirby
exhausting = 0
spitting = false
swallowing = false

//Bouncing states
bouncing = 0
can_bounce = 0

is_dead = false

//health system
hp=3


//Button variable
action_hold_time = 0


/*
//platforming state constants
STILL = 0
WALKING = 1
DASHING = 2
SKIDDING = 3
JUMPING = 4
FLOATING = 5
FALLING = 6
FALLING_FLOATING = 7
DUCKING = 8
//state = STILL
*/

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite constants
SPRITES = global.DS_SPRITES_KIRBY  //SPRITES is a ds_map that contains sprite name and its index
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>show_debug_message('DEAD')
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///This timer is shared between spitting star / swallowing

//for spitting event
if(spitting){
    spitting = false
    stuffed = false
}

//for swallowing event
else if(swallowing){
    swallowing = false
    stuffed = false
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Finished exhausting
exhausting = 0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Inhale timer - inhale nothing and inhale enemies

//Alarm 3 is used in 2 scenarios
//First, INHALE_DELAY - delay kirby stop inhaling animation (to make a better gameplay experience)
//when it goes off, change kirby state to inhaling = false

//Second, INHALING_ENEMY_TIMER - use with event 1 when inhaling something
//when it goes off, first it change kirby state to stuffing for stuffing transition animation (which start another timer)
//then it change kirby state to stuffed (big) finally
if(inhaling_enemy){
    if(not stuffing){
        stuffing = true
        alarm[3] = STUFFING_DELAY
    } else {
        stuffing = false
        inhaling_enemy = false
        stuffed = true
        inhaling = 0
    }
} else if(inhaling){
    inhaling = 0
}

//destroy inhale obj in either scenario
if(instance_exists(inhale_range_obj)) instance_destroy(inhale_range_obj)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Nothing here, Alarm 2 is used for update falling animation
//show_debug_message('off')
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Deactivate puffing state
puffing = 0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>alarm is set in Step/Input Control</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set dashing to false when alarm out
dashing = false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Get the player's input

key_left = keyboard_check(INPUT.LEFT)   //1 if pressing right, 0 otherwise
key_right = keyboard_check(INPUT.RIGHT)    //-1 if pressing left, 0 otherwise
key_down = keyboard_check(INPUT.DOWN)
key_jump = keyboard_check(INPUT.JUMP)     //A
key_action = keyboard_check(INPUT.ACTION)  //B


key_just_left = keyboard_check_pressed(INPUT.LEFT)
key_just_right = keyboard_check_pressed(INPUT.RIGHT)
key_just_down = keyboard_check_pressed(INPUT.DOWN)
key_just_jump = keyboard_check_pressed(INPUT.JUMP)
key_just_action = keyboard_check_pressed(INPUT.ACTION)

key_release_action = keyboard_check_released(INPUT.ACTION)

move = key_right-key_left;  //if pressing both right and left, movement cancels out
move_pulse = key_just_right-key_just_left

//if(keyboard_check_pressed(ord('Q'))) image_xscale = -image_xscale

///if(keyboard_check_pressed(ord('D')))  x += 1
//if(keyboard_check_pressed(ord('A')))  x -= 1
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement
is_moving = (move != 0)
is_moving_same_dir_again = (sign(last_dir) == sign(move_pulse))

if(inhaling or exhausting or swallowing) is_moving = 0

if (is_moving and not sliding){
    dir = move
}

/*
if ((position_meeting(bbox_left,bbox_bottom+1,obj_solidtop)  or position_meeting(bbox_right,bbox_bottom+1,obj_solidtop))) {
    
    left_solidtop_id = instance_position(bbox_left,bbox_bottom+1,obj_solidtop)
    right_solidtop_id = instance_position(bbox_right,bbox_bottom+1,obj_solidtop)
    
    if (left_solidtop_id != noone) left_on_ground = bbox_bottom+1 == left_solidtop_id.y
    else left_on_ground = false
    if (right_solidtop_id != noone) right_on_ground = bbox_bottom+1 == right_solidtop_id.y
    else right_on_ground = false
    
    if (left_on_ground or right_on_ground) on_ground = true
    else on_ground = false

} else if place_meeting(x,y+1,obj_solid) on_ground = true
else on_ground = false
*/

//on_ground logic
if (vsp &gt;= 0 and collision_rectangle(bbox_left,bbox_bottom,bbox_right,bbox_bottom+1,obj_solidtop,0,1)){
    on_ground = true
//} else if (collision_rectangle(bbox_left,bbox_bottom,bbox_right,bbox_bottom+1,obj_slope,0,0)) {
} else if (position_meeting(x,bbox_bottom+1,obj_slope)){
    on_ground = true
} else on_ground = false


//Dashing logic
if (is_moving and not floating and not sliding){

    //If player move again in the same direction when on ground and alarm not off, make him dash
    if(on_ground){
        if(is_moving_same_dir_again and alarm[0] &gt; 0 and alarm[0] &lt; DASH_TIMER){
            dashing = true
        }   
    }
    
    //alarm 0 reset when player moves, and countdowns as soon as player stop moving
    //If player move again while alarm is not off, he can trigger dashing (code above)
    //this also prevent alarm to countdown while player still moving/dashing
    alarm[0] = DASH_TIMER
    
}

//Horizontal speed logic
if(is_moving and not sliding){  
    //Determine max speed
    if(dashing){
        max_hsp = DASH_SPD
    } else {
        max_hsp = WALK_SPD
        if(spitting) max_hsp = 1
    }
    
    //skidding
    if(hsp != 0 and dir != sign(hsp)){
        //show_debug_message('SKIDDING')
        hsp -= sign(hsp)*SKID_DECELERATION;
        skidding = 1
        
    } else {
        //If player try to move, accelerate to max speed
        hsp = dir * min(abs(hsp) + ACCELERATION, max_hsp)
        skidding = 0
    }
}
else {
    //when player stop moving, decelerate to zero
    if(hsp &gt; 0) {                    
        hsp -= DECELERATION
        if(hsp &lt; 0) hsp = 0
    } else if (hsp &lt; 0) {
        hsp += DECELERATION
        if(hsp &gt; 0) hsp = 0
    }
    skidding = 0
}


//Update vsp with GRAV
if(floating) vsp = min(vsp + FLOAT_GRAV, VSP_MAX_FLOAT)
else vsp = min(vsp + GRAV, VSP_MAX)

//Floating
if ((key_just_jump) and (jumping or falling or floating) and not stuffed and not (bouncing or inhaling or exhausting or spitting or swallowing)){
    floating = 1
    jumping = 0
    falling = 0
    dashing = 0
    vsp = -FLOAT_SPD
}

//Jumping
if (on_ground and not (floating or sliding or bouncing) and not (inhaling or exhausting or spitting or swallowing)){
    if(key_just_jump){
        vsp = -JUMP_SPD
        jumping = 1
    } else {
        //vsp = 0
        jumping = 0
    }
} else {    //If not on ground
    if(jumping and not key_jump){      //for longer jump when holding key
        vsp += JUMP_DECEL
    }
    
    //if (vsp &gt; 0){
    //    jumping = 0   
    //}
    
}

///Falling Check
//if vsp exceed grav = if more than one step passed increasing vsp
if(vsp &gt; GRAV) {
    //alarm 2 is used for countdown falling period to change falling sprite
    //when it goes off, kirby sprite will change from fall1 to fall2
    //timer will start countdown only when start to fall but not floating
    if((not falling) or floating){
        alarm[2] = UPDATE_FALLING_TIMER
    }
    jumping = 0
    falling = 1
} else 
    falling = 0


///Bouncing
if (can_bounce){
    vsp = -BOUNCE_SPD
    bouncing = 1
    can_bounce = 0
}
//if touch ground again after bouncing state, stop bouncing
if(falling or (vsp &gt; 0 and on_ground and bouncing)){    
    bouncing = 0
}


//Ducking
//if on ground and not doing anything else
if (on_ground and key_down and not stuffed and not (floating or falling or bouncing or is_moving or sliding or inhaling or exhausting)){
    ducking = 1
} else {
    ducking = 0
}

//Swallowing
if(on_ground and key_just_down and stuffed and not (spitting)){
    swallowing = true
    alarm[5] = SWALLOW_TIMER
    if(transformable) event_user(3)
}

//Sliding
//if sliding off edge or come to stop
if(falling or hsp == 0){
    sliding = 0
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Action buttom
event_user(2)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Slope + Solidtop/Solid Collision

//Slope Collision
//  All slope objects are inherited from obj_slope

//slope vertical collision
if(vsp!= 0 and position_meeting(x,floor(bbox_bottom+vsp),obj_slope)){      //if moving and colliding with slope in direction moving
     while(!position_meeting(x,bbox_bottom+sign(vsp),obj_slope)){   //move in 1 pixel until contact
         y += sign(vsp);
     }
     
     event_user(14)
     vsp = 0
     //show_debug_message('ON SLOPE')
}

//walking on slope collision
//First, check if player is going up slope or not
//This is done by checking that next position horizontally is still on slope, if yes it means player is going up on the slope
slope_y_offset = 0
slope_up_inst = instance_position(floor(x+hsp),bbox_bottom,obj_slope);  //check if next position is still on slope
if (slope_up_inst != noone){    //if yes it will be that slope object id
    
    if(slope_up_inst.SLOPE_RATIO == 0){     //if it's "obj_slope_end" then it will always push player up to its top
        rel_x = sprite_get_height(slope_up_inst.sprite_index);         
    } else {
        //calculate relative x position of player from the slope x (very left)
        rel_x = floor(x+hsp) - slope_up_inst.x     
        if(slope_up_inst.SLOPE_RATIO &lt; 0){  //if opposite slope direction invert the relative value
            rel_x = sprite_get_width(slope_up_inst.sprite_index) - 1 - rel_x;
        }
    }
    //show_debug_message(string(slope_up_inst)+" "+string(rel_x));
    //set player at position relative to that slope y position using rel_x as a offset
    player_y_above_offset =  FEET_OFFSET - sprite_get_height(slope_up_inst.sprite_index)
    newy = slope_up_inst.y - player_y_above_offset - rel_x;
    //y = floor(newy)
    slope_y_offset = newy - y
    
    
} else {
    //If not going up, check if he is going down on slope or not
    //Check first if player is standing on slope, then check if next position player would be if he is going down on slope is still on slope
    standing_slope = instance_position(x,bbox_bottom+1,obj_slope);  //check if standing on slope
    if(standing_slope != noone){
        slope_down_inst = instance_position(floor(x+hsp),floor(bbox_bottom+abs(hsp)+1),obj_slope);  //check if still on slope at position he would be if he goes down on slope
        if(slope_down_inst != noone){       //if yes it will be that slope object id
            
            if(slope_down_inst.SLOPE_RATIO == 0){  //if it's "obj_slope_end" then it will always push player up to its top
                rel_x = sprite_get_height(slope_down_inst.sprite_index);           
            } else {
                //calculate relative x position of player from the slope x (very left)
                rel_x = floor(x+hsp) - slope_down_inst.x;
                if(slope_down_inst.SLOPE_RATIO &lt; 0){
                    rel_x = sprite_get_width(slope_down_inst.sprite_index) - 1 - rel_x;   //if opposite slope direction invert the relative value
                }
            }
            
            //show_debug_message(string(slope_down_inst)+" "+string(rel_x));
            //set player at position relative to that slope y position using rel_x as a offset
            player_y_above_offset =  FEET_OFFSET - sprite_get_height(slope_down_inst.sprite_index)
            newy = slope_down_inst.y - player_y_above_offset - rel_x;
            //y = floor(newy)
            slope_y_offset = newy - y
        }
    }
    
}

//If player is falling and about to collide with solidtop (but not solid)
if(vsp &gt;= 0){
    var solidtop = collision_rectangle(bbox_left,bbox_bottom,bbox_right,bbox_bottom+vsp,obj_solidtop,0,1)
    //if (solidtop or position_meeting(x,y+FEET_OFFSET+1,obj_slope)) //if standing on ground
    //{
        
        //check if it is solidtop but not solid
        if(solidtop and solidtop.object_index != obj_solid){ 
            // set player on top of solidtop and set vertical speed to zero
            y = solidtop.y - sprite_get_height(solidtop.sprite_index) 
            
            event_user(14)
            vsp = 0
        }
        //if(solidtop) show_debug_message(solidtop.object_index)
    //}
}

//vertical collision with solid
if(vsp != 0 and place_meeting(x,floor(y+vsp),obj_solid)){

    //snap to wall when falling/rising very near to vertical walls
    //this make it easier to jump through small gap
    for(i=SMALL_GAP_OFFSET; i&gt;0; i-=1){
        if(vsp &lt; 0 and !place_meeting(x+i,floor(y+vsp),obj_solid)){        
            x += i
            break
        } else if(vsp &lt; 0 and !place_meeting(x-i,floor(y+vsp),obj_solid)){
            x -= i
            break
        }
    }
    
    if (place_meeting(x,floor(y+vsp),obj_solid)){
        //handle normally
        while(!place_meeting(x,y+sign(vsp),obj_solid)){
            y += sign(vsp) //pixel-perfect snap
        }
        
        event_user(14)
        vsp = 0
    }  
}
y += slope_y_offset
y = floor(y+vsp)

//horizontal collision with solid
if(hsp != 0 and place_meeting(floor(x+hsp),y,obj_solid)){
    while(not place_meeting(x+sign(hsp),y,obj_solid)){
        x = x+sign(hsp) //pixel-perfect snap
    }
    hsp = 0
}
x = floor(x+hsp)

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Last Direction

if (is_moving){
    last_dir = dir
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Kill Player

instance_create(x,y,obj_kirby_dead)
instance_destroy()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="24">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check condition for bouncing off ground
//this will be called when hitting the ground (called from collision code)

//bounce condition
//can_bounce = bounce can happen next step or not
//bouncing = in a middle of bounce animation or not

if(not stuffed and not (inhaling or exhausting or spitting or swallowing) and vsp &gt;= VSP_MAX and alarm[2] &lt; 0){
    can_bounce = 1
    //show_debug_message(can_bounce)
} else {
    can_bounce = 0
}

/*
if(not can_bounce and not bouncing){
    if(vsp &gt;= VSP_MAX and alarm[2] &lt; 0){
        can_bounce = 1
    } 
} else if (vsp &gt; 0){
    can_bounce = 0
    bouncing = 0
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Transformation

show_debug_message('TRANFORMED')
show_debug_message(ability)

ability_obj = noone
switch (ability){
    case ABILITY_BEAM: ability_obj = obj_kirby_beam; break;

    default: ability_obj = noone;
}

if (ability_obj){
    instance_create(x,y,ability_obj)
    instance_destroy()
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Action Button (puffing, sliding, inhaling, attacking)
if(key_just_action){
    //if floating, return to normal state
    if(floating and not puffing){
        event_user(0)   //Puffing event
    }
    
    else if(ducking and not sliding){
        //Sliding event
        sliding = 1
        hsp = dir * SLIDING_SPD
    }
    
    else {
        if (not stuffed and not (sliding or puffing or spitting)){
            //Inhaling
            inhaling = 1
            if(not instance_exists(inhale_range_obj)){
                inhale_range_obj = instance_create(x,y,obj_inhale_range)
            }
        }
        else if (stuffed and not spitting and not swallowing){
            spitting = true
            instance_create(x,y,obj_star_spit)
            alarm[5] = SPIT_TIMER
        }
    }
    
}
if(key_action){    
    action_hold_time += 1
    if(inhaling and action_hold_time &gt; SUPER_INHALE_THRESHOLD){
        inhaling = 2
    }
    if(inhaling and not inhaling_enemy and action_hold_time &gt; EXHAUST_THRESHOLD){
        exhausting = 1
        alarm[4] = EXHAUST_TIMER
        inhaling = 0
        if(instance_exists(inhale_range_obj)) instance_destroy(inhale_range_obj)
    }
}

//Release event
if(key_release_action){
    if(action_hold_time &gt; BUTTON_HOLD_THRESHOLD){
        hold_action = true
    }
    
    action_hold_time = 0
    if(inhaling and not inhaling_enemy) alarm[3] = INHALE_DELAY  //delay before actual stop
    
}


//Single Press Action
if(key_just_action){
    //B

    //Dash + B
    
    //Dash + Jump + B
    
    //Up + B
    
    //Down + B
}


//Holding Action
if(key_release_action){
    //Hold B
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Inhale Enemy Event
//This get called by obj_inhale_range

inhaling_enemy = true
alarm[3] = INHALING_ENEMY_TIMER
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Puffing event

//This event is called when puffing can occur (press action after floating)
//set timer for puffing to go off
alarm[1] = PUFFING_TIMER
//activate puffing state
puffing = 1
//deactivate states
floating = 0
dashing = 0

//create puffing object
if (not instance_exists(obj_puff))
instance_create(x,y,obj_puff)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Switch case
loop_animation = true
switch(sprite_index){
    case spr_kirby_float: image_index = image_number - 12; break;
    case spr_kirby_puff: loop_animation = false; break;
    case spr_kirby_fall: image_index = image_number - 2; break;
    case spr_kirby_fall2: loop_animation = false; break;
    case spr_kirby_bounce : loop_animation = false; break;
    case spr_kirby_inhale: image_index = image_number - 2; break;
    case spr_kirby_inhale2: image_index = image_number - 2; break;
    case spr_kirby_exhaust: loop_animation = false; break;
    case spr_kirby_stuffing: loop_animation = false; break;
    case spr_kirby_big_jump : loop_animation = false; break;
    case spr_kirby_big_fall : image_index = image_number - 2; break;
    case spr_kirby_spit : loop_animation = false; break;
    case spr_kirby_spit2 : loop_animation = false; break;
    case spr_kirby_swallow : loop_animation = false; break;
    
    default:  //do nothing
}



//run this animation once
if(not loop_animation){
    image_speed = 0
    image_index = image_number - 1
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create obj_camera

if(not instance_exists(obj_camera)){
    instance_create(0,0,obj_camera)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite Control

//Kirby sprite is determined by his current state, the default state is STILL state

image_xscale = dir
last_sprite = sprite_index

//use to reset sprite image when changing to new sprite, unless state to be other below
start_image_index = 0

//if no something in mouth, use normal sprite
if(not stuffed){
    if (inhaling){
        if(stuffing) sprite_index = SPRITES[? 'stuffing']
        else if(inhaling == 2) sprite_index = SPRITES[? 'inhale2']
        else sprite_index = SPRITES[? 'inhale']
        image_speed = 1
    } else if (exhausting){
        sprite_index = SPRITES[? 'exhaust']
        image_speed = 0.2
    } else if (puffing){
        sprite_index = SPRITES[? 'puff']
        image_speed = 0.2
    } else if (sliding){
        sprite_index = SPRITES[? 'slide']
        image_speed = 1
    } else if (floating){    
        sprite_index = SPRITES[? 'float']
        image_speed = 1
    } else if(jumping){
        sprite_index = SPRITES[? 'jump']
        image_speed = 1
    } else if (bouncing) {
        sprite_index = SPRITES[? 'bounce']
        image_speed = 1
    } else if (falling) {
        if(alarm[2] &gt; 0){
            sprite_index = SPRITES[? 'fall']
            if (last_sprite != SPRITES[? 'jump']) start_image_index = sprite_get_number(SPRITES[? 'fall']) - 2
        } else {
            sprite_index = SPRITES[? 'fall2']
        }
        image_speed = 1
    } else if (skidding){
        sprite_index = SPRITES[? 'skid']
        image_speed = 1
    } else if(ducking) {
        sprite_index = SPRITES[? 'duck']
        image_speed = 0
    } else if(is_moving or hsp != 0){
        if(dashing) sprite_index = SPRITES[? 'run']          
        else sprite_index = SPRITES[? 'walk']
        image_speed = 0.5
    } else {
        if(last_sprite == SPRITES[? 'slide']  ){
            sprite_index = SPRITES[? 'slide2']  
        }
        else if((last_sprite == SPRITES[? 'fall']  ) or (last_sprite == SPRITES[? 'fall2']  )){
            sprite_index = SPRITES[? 'duck']  
        }
        else sprite_index = SPRITES[? 'still']   
        image_speed = 0
    }
} else {
    if(spitting){
        sprite_index = SPRITES[? 'spit']
        if(alarm[5] &lt; sprite_get_number(SPRITES[? 'spit2'])) sprite_index = SPRITES[? 'spit2']
        image_speed = 1
    } else if (swallowing){
        sprite_index = SPRITES[? 'swallow']
        image_speed = 1
    } else if(jumping){
        sprite_index = SPRITES[? 'big_jump']
        image_speed = 1
    } else if (falling) {
        sprite_index = SPRITES[? 'big_fall']
        image_speed = 1
    } else if (skidding){
        sprite_index = SPRITES[? 'big_skid']
        image_speed = 1
    } else if(is_moving or hsp != 0){        
        sprite_index = SPRITES[? 'big_walk']
        image_speed = 1
    } else {
        sprite_index = SPRITES[? 'big_still']   
        image_speed = 0
    }
}


//Reset index if sprite changed
if(last_sprite != sprite_index)
image_index = start_image_index  //default should be 0
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Actual Drawing

draw_self()

//Debug stuffs
draw_debug_text(hsp,vsp,on_ground,falling,x,y,inhaling,sprite_get_name(sprite_index))

state = ''

if(dashing) state += ' D'
if(jumping) state += ' J'
if(floating) state += ' F'
if(sliding) state += ' S'
if(inhaling) state += ' I'
if(spitting) state += ' Sp'
if(swallowing) state += ' Sw'
if(skidding) state += ' s'
if(bouncing) state += ' b'
if(falling) state += ' f'
if(ducking) state += ' d'


draw_set_colour(c_black)
draw_text_transformed(x-16,y-32,state,2,2,0)
draw_set_colour(c_white)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
